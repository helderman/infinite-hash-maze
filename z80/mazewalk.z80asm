; ---------------------------------
; Infinite Hash Maze
; ---------------------------------

; MZ-700 memory map
VRAM:	EQU	0D000H	; video RAM (40x25 character matrix)
SPACE:	EQU	00H	; display code: space
WALL:	EQU	43H	; display code: whole wall character
WALLA:	EQU	3AH	; display code: half horizontal above
WALLB:	EQU	7AH	; display code: half horizontal below
WALLL:	EQU	3BH	; display code: half vertical left
WALLR:	EQU	7BH	; display code: half vertical right

; MZ-700 system calls
GETKEY:	EQU	001BH	; poll keyboard (11H-14H = down/up/right/left)
VBLANK:	EQU	0DA6H	; wait until start of vertical blanking period
DPCT:	EQU	0DDCH	; display control
CLS:	EQU	0C6H	; display code to clear screen

; Hash steps for horizontal walls
HLEFT:	EQU	-563
HRIGHT:	EQU	563
HDOWN:	EQU	-761
HUP:	EQU	761

; Hash steps for vertical walls
VLEFT:	EQU	-1409
VRIGHT:	EQU	1409
VDOWN:	EQU	-397
VUP:	EQU	397

; ---------------------------------
; Macros
; ---------------------------------

; LDAIYL - workaround for unrecognized LD A,IYL

LDAIYL:	MACRO
	DEFB	0FDH	; prefix for IY
	LD	A,L
	ENDM

; HASHI - hash and increment
; in:     DE = post-increment for seed
; in/out: HL = seed
; out:    PO = wall, PE = no wall
; 3 bytes; 19 cycles

HASHI:	MACRO
	LD	A,L
	XOR	H
	ADD	HL,DE
	ENDM

; CALCH - calculate all horizontal walls, store them in workspace
; Clobbers AF, BC, DE, HL, IY
; 42 or 46 bytes; 5327 or 6467 cycles (worst case)

CALCH:	MACRO	CHAR1 CHAR2
	LD	DE,HRIGHT
	LD	HL,(HCURR)
	LD	IY,WORKSP+18
.OUTER:	LD	B,10
.INNER:	HASHI
	JP	PE,.SKIP
	LD	(IY+0),CHAR1
	IF	CHAR2!=SPACE
	LD	(IY+19),CHAR2
	ENDIF
.SKIP:	INC	IY
	INC	IY
	DJNZ	.INNER	; 805 or 995 cycles
	LD	C,18	; B is already zero
	ADD	IY,BC
	LD	BC,HDOWN-10*HRIGHT
	ADD	HL,BC
	LDAIYL
	CP	(WORKSP+13*19-1)&0FFH	; repeat 6 times
	JR	NZ,.OUTER
	ENDM

; CALCV - calculate all vertical walls, store them in workspace
; Clobbers AF, BC, DE, HL, IY
; 42 or 46 bytes; 5642 or 6839 cycles (worst case)

CALCV:	MACRO	CHAR1 CHAR2
	LD	DE,VRIGHT
	LD	HL,(VCURR)
	LD	IY,WORKSP
.OUTER:	LD	B,9
.INNER:	HASHI
	JP	PE,.SKIP
	LD	(IY+0),CHAR1
	IF	CHAR2!=0
	LD	(IY+1),CHAR2
	ENDIF
.SKIP:	INC	IY
	INC	IY
	DJNZ	.INNER	; 724 or 895 cycles
	LD	C,20	; B is already zero
	ADD	IY,BC
	LD	BC,VDOWN-9*VRIGHT
	ADD	HL,BC
	LDAIYL
	CP	(WORKSP+14*19)&0FFH	; repeat 7 times
	JR	NZ,.OUTER
	ENDM

; CALCC - calculate all corner stones, store them in workspace
; Clobbers AF, BC, DE, HL, IY
; Always exits with B=0
; 54 bytes; 10845 cycles (worst case)

CALCC:	MACRO	CHAR1 CHAR2 D1 D2
	LD	IY,WORKSP+18
.OUTER:	LD	B,9
.INNER:	INC	IY
	LD	E,(IY-D1)
	LD	D,(IY+D1)
	LD	A,E
	OR	D
	OR	(IY-D2)
	OR	(IY+D2)
	JR	Z,.SKIP2	; no walls at all here
	XOR	A		; A := SPACE
	CP	E
	JR	NZ,.SKIP1
	LD	E,CHAR1
.SKIP1:	LD	(IY+0),E
	CP	D
	JR	NZ,.SKIP2
	IF	D1=1		; workaround for z80asm bug
	LD	(IY+1),CHAR2
	ENDIF
	IF	D1=19		; workaround for z80asm bug
	LD	(IY+19),CHAR2
	ENDIF
.SKIP2:	INC	IY
	DJNZ	.INNER
	LD	C,20		; B is already zero
	ADD	IY,BC
	LDAIYL
	CP	(WORKSP+13*19-1)&0FFH	; repeat 6 times
	JR	NZ,.OUTER
	ENDM

; ---------------------------------
; Code
; ---------------------------------

	ORG	4000H

START:	LD	A,CLS
	CALL	DPCT
	CALL	CLRWSP
	CALL	DRAWX
	LD	A,WALLR
	CALL	SNR2
	CALL	DUMPX
	CALL	CLRWSP
	CALL	DRAWY
	LD	A,WALLB
	CALL	SNR2
	CALL	DUMPY
	LD	IX,VRAM+458	; center of screen
	LD	(IX+41),0FEH
	LD	(IX+42),0FDH
	LD	(IX+81),0FBH
	LD	(IX+82),0F7H
POLL:	LD	HL,POLL
	PUSH	HL	; push return address (main loop)
	CALL	GETKEY	; it's OK for the stack to clobber the workspace here
	CALL	CLRWSP
	SUB	11H
	JP	Z,MOVD	; 11h = down (too far for JR)
	CP	3
	JR	Z,MOVL	; 14h = left
	RET	NC
	DEC	A
	JR	NZ,MOVR	; 13h = right
	; fall through to MOVU; 12h = up

; MOVU - player moves up (walls move down)

MOVU:	LD	A,(IX+1)
	OR	(IX+2)
	RET	NZ	; blocked by wall
	CALL	DRAWY
	CALL	DUMPYV
	LD	A,WALLA
	CALL	DUMPYS
	LD	HL,YCURR
	INC	(HL)
	; fall through to MOVY

; MOVY - change player position vertically

MOVY:	LD	A,(HL)
	SUB	5
	RET	C
	LD	BC,HUP
	LD	DE,VUP
	JR	Z,MOVXY
	LD	BC,HDOWN
	LD	DE,VDOWN
	JR	MOVXY4

; MOVL - player moves left (walls move right)

MOVL:	LD	A,(IX+40)
	OR	(IX+80)
	RET	NZ	; blocked by wall
	CALL	DRAWX
	CALL	DUMPXV
	LD	A,WALLL
	CALL	DUMPXS
	LD	HL,XCURR
	DEC	(HL)
	; fall through to MOVX

; MOVX - change player position horizontally

MOVX:	LD	A,(HL)
	SUB	5
	RET	C
	LD	BC,HRIGHT
	LD	DE,VRIGHT
	JR	Z,MOVXY
	LD	BC,HLEFT
	LD	DE,VLEFT
MOVXY4:	LD	A,4
MOVXY:	LD	(HL),A
	LD	HL,(HCURR)
	ADD	HL,BC
	LD	(HCURR),HL
	LD	HL,(VCURR)
	ADD	HL,DE
	LD	(VCURR),HL
	RET

; MOVR - player moves right (walls move left)

MOVR:	LD	A,(IX+43)
	OR	(IX+83)
	RET	NZ	; blocked by wall
	LD	HL,XCURR
	INC	(HL)
	CALL	MOVX
	CALL	DRAWX
	CALL	DUMPXV
	LD	A,WALLR
	; fall through to DUMPXS

; DUMPX - render walls after horizontal movement
; DUMPXV - VBLANK + DUMPX
; DUMPXS - SNR2 + VBLANK + DUMPX
; Must be called with B=0; always exits with B=0

DUMPXS:	CALL	SNR2
DUMPXV:	CALL	VBLANK
DUMPX:	LD	HL,(XCURR)
	LD	C,L		; C := (XCURR)
	LD	A,H		; A := (YCURR)
	BIT	2,C		; NZ if C=4, an edge case
	JR	Z,DUMPX1
	INC	C		; C := 5, and still NZ
DUMPX1:	LD	HL,CODEX
	ADD	HL,BC
	LD	DE,DUMPX6
	LD	C,7
	LDIR			; self-modifying code
	LD	DE,VRAM
	LD	HL,WORKSP+16
	JR	Z,DUMPX2	; ZF still from BIT 2,C
	INC	HL
DUMPX2:	OR	A
	JR	NZ,DUMPX3
	LD	C,19		; B is already 0
	ADD	HL,BC
DUMPX3:	LD	C,16		; B is already 0
	SUB	1
	JR	C,DUMPX4
	JR	Z,DUMPX5
	SBC	HL,BC		; beforehand, CF is cleared
	JR	DUMPX6
DUMPX4:	LD	A,4
DUMPX5:	INC	HL
	INC	HL
	INC	HL
DUMPX6:	DEFS	+7		; code copied here from CODEX
	JP	PE,DUMPX6	; inner loop: 8*60 cycles
	LD	C,A
	LD	A,E
	CP	0E8H		; 03E8H = 1000
	LD	A,C
	JR	NZ,DUMPX3	; outer loop
	RET

; MOVD - player moves down (walls move up)

MOVD:	LD	A,(IX+121)
	OR	(IX+122)
	RET	NZ	; blocked by wall
	LD	HL,YCURR
	DEC	(HL)
	CALL	MOVY
	CALL	DRAWY
	CALL	DUMPYV
	LD	A,WALLB
	; fall through to DUMPYS

; DUMPY - render walls after vertical movement
; DUMPYV - VBLANK + DUMPY
; DUMPYS - SNR2 + VBLANK + DUMPY
; Must be called with B=0; always exits with B=0

DUMPYS:	CALL	SNR2
DUMPYV:	CALL	VBLANK
DUMPY:	LD	A,(XCURR)
	LD	C,A
	ADD	A,A
	CP	8
	ADC	A,C
	LD	C,A
	LD	HL,CODEY-1
	ADD	HL,BC		; HL=CODEY+0/3/6/9/11 for (XCURR)=0/1/2/3/4
	LD	DE,DUMPY5
	LD	C,11		; B is already 0
	LDIR			; self-modifying code
	LD	HL,(XCURR)
	XOR	A
	CP	H
	JR	NZ,DUMPY1	; if (YCURR)=0, C=0 (from LDIR)
	LD	C,19		; if (YCURR)<>0, C=19
DUMPY1:	CP	L
	JR	NZ,DUMPY2
	INC	C		; if (XCURR)=0, increment C
DUMPY2:	LD	A,H		; A:=(YCURR)
	LD	HL,WORKSP+19	; first cornerstone (B1)
	ADD	HL,BC
	LD	DE,VRAM
DUMPY3:	LD	C,40		; width of screen
	SUB	1
	JR	C,DUMPY4
	JR	Z,DUMPY5
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL
	JR	DUMPY6
DUMPY4:	LD	A,4
DUMPY5:	DEFS	+11		; code will be copied here from CODEY
	LDI
	JP	PE,DUMPY5	; inner loop: 8*108 cycles
	INC	HL
	INC	HL
	INC	HL
DUMPY6:	LD	C,A
	LD	A,E
	CP	0E8H
	LD	A,C
	JR	NZ,DUMPY3
	RET

; DRAWX - draw walls, misaligned horizontally

DRAWX:	CALCH	WALL SPACE
	CALCV	WALLR WALLL
	CALCC	WALLR WALLL 1 19
	RET

; DRAWY - draw walls, misaligned vertically

DRAWY:	CALCH	WALLB WALLA
	CALCV	WALL SPACE
	CALCC	WALLB WALLA 19 1
	RET

; SNR2 - search and replace two display codes in workspace
; in: A = display code that needs to be replaced by WALL
;         (A xor 40H is the second display code; will be replaced by SPACE)
; Must be called with B=0; always exits with B=0
; Clobbers AF, C, E, HL
; 17555 cycles (worst case, walls everywhere)

SNR2:	LD	E,WALL
	CALL	SNR
	XOR	40H	; WALLA <-> WALLB, WALLL <-> WALLR
	LD	E,B	; E := SPACE
SNR:	LD	C,246
	LD	HL,WORKSP
SNR1:	CPIR
	RET	NZ
	DEC	HL
	LD	(HL),E
	INC	HL
	JP	PE,SNR1
	RET

; CLRWSP - fill entire workspace with SPACE
; Clobbers F, BC, DE, HL

CLRWSP:	LD	HL,WORKSP
	LD	DE,WORKSP+1
	LD	BC,245
	LD	(HL),SPACE
	LDIR
	RET

; ---------------------------------
; Code that is copied elsewhere
; ---------------------------------

; CODEX - pick a subsequence of 5 instructions (7 bytes, 50 cycles)
;         to fill a row of 5 characters in V-RAM

CODEX:	INC	DE
	INC	DE
	INC	DE
	LDI
	LDI
	INC	DE
	INC	DE
	INC	DE
	LDI

; CODEY - pick a subsequence of 7 instructions (11 bytes, 82 cycles)
;         to fill a row of 5 characters in V-RAM

CODEY:	DEC	HL	; first instruction when (XCURR)=0
	LDI
	DEC	HL	; first instruction when (XCURR)=1
	LDI
	DEC	HL	; first instruction when (XCURR)=2
	LDI
	LDI		; first instruction when (XCURR)=3
	LDI		; first instruction when (XCURR)=4
	DEC	HL
	LDI
	DEC	HL
	LDI
	DEC	HL
	LDI

; ---------------------------------
; Initialized variables
; ---------------------------------

; XCURR - current X position, sub-cell
;
; 0: ---+----+----+----+----+----+----+----+-
; 1: --+----+----+----+-PL-+----+----+----+--
; 2: -+----+----+----+----+----+----+----+---
; 3: +----+----+----+----+----+----+----+----
; 4: ----+----+----+----+----+----+----+----+

XCURR:	DEFB	1

; YCURR - current Y position, sub-cell
;
;  0   1   2   3   4
;  |  -+-  |   |   |
;  |   |  -+-  |   |
;  |   |   |  -+-  |
;  |   |   |   |  -+-
; -+-  |   |   |   |
;  |  -+-  |   |   |
;  |   |  -+-  |   |
;  |   |   |  -+-  |
;  |   |   |   |  -+-
; -+-  |   |   |   |
;  |  -+-  |   |   |
;  |   |  -+-  |   |
;  |   PL  |  -+-  |
;  |   PL  |   |  -+-
; -+-  |   |   |   |
;  |  -+-  |   |   |
;  |   |  -+-  |   |
;  |   |   |  -+-  |
;  |   |   |   |  -+-
; -+-  |   |   |   |
;  |  -+-  |   |   |
;  |   |  -+-  |   |
;  |   |   |  -+-  |
;  |   |   |   |  -+-
; -+-  |   |   |   |

YCURR:	DEFB	1

; HCURR - current position, hashed for horizontal walls

HCURR:	DEFW	33322+4*HLEFT+2*HUP

; VCURR - current position, hashed for vertical walls

VCURR:	DEFW	35273+3*VLEFT+3*VUP

; ---------------------------------
; Uninitialized variables
; ---------------------------------

; WORKSP - workspace for display codes
;
;    0123456789........18
;
; A   |.|.|.|.|.|.|.|.|.
; B  -+-+-+-+-+-+-+-+-+-
; C  .|.|.|.|.|.|.|.|.|.
; D  -+-+-+-+-+-+-+-+-+-
; E  .|.|.|.|.|.|.|.|.|.
; F  -+-+-+-+-+-+-+-+-+-
; G  .|.|.|.|.|.|.|.|.|.
; H  -+-+-+-+-+-+-+-+-+-
; I  .|.|.|.|.|.|.|.|.|.
; J  -+-+-+-+-+-+-+-+-+-
; K  .|.|.|.|.|.|.|.|.|.
; L  -+-+-+-+-+-+-+-+-+-
; M  .|.|.|.|.|.|.|.|.|.
;
; Legend:
; | vertical wall
; - horizontal wall
; + corner stone
; . spill from misaligned horizontal wall above or vertical wall left
;
; Display codes:
; +-----+  +-----+  +-----+  +-----+  +-----+  +-----+
; |     |  |/////|  |/////|  |     |  |//|  |  |  |//|
; |     |  |/////|  |-----|  |-----|  |//|  |  |  |//|
; |     |  |/////|  |     |  |/////|  |//|  |  |  |//|
; +-----+  +-----+  +-----+  +-----+  +-----+  +-----+
;  SPACE    WALL     WALLA    WALLB    WALLL    WALLR
;
; Display codes are stored in the workspace as bytes, row by row:
; A1,A2,...,A18,B0,B1,B2,...,B18,C0,......,M18
; Notice A0 is not stored (tiny optimization; it is unused),
; leaving a total of 19*13-1 = 246 bytes.
;
; Row M and column 18 are never visible on screen;
; they are only used to calculate adjacent corner stones.

WORKSP:		; DEFS +246 left out to keep the binary file small

	END
